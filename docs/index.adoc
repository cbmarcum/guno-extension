= GUNO Extension Documentation
:author: Carl Marcum
:email: carl.marcum@codebuilders.net
:toc: left

== Introduction
*UNO* stands for *Universal Network Objects* and is the base component technology for **Apache OpenOffice**.

*GUNO* stands for *Groovy UNO* and is an *Apache Groovy* language extension of the **Java UNO API's**. The artifact of this extension is a Java jar file that when used in a Groovy script or class adds convenience methods to the regular Java UNO API's.

*The goal of the Groovy UNO Extension is to allow UNO programming that is less verbose than using the Java UNO API's alone.*

These methods are implemented using **Groovy Extension Modules**. An extension module allows you to **add new methods to existing classes**, including classes which are precompiled, like classes from the JDK or in this case Java UNO classes. These new methods, unlike those defined through a metaclass or using a category, are available globally.

Aside from a few general methods, initial efforts have been on enhancing the spreadsheet API's and future work will be on enhancing the other applications.

This guide is not intended to be an OpenOffice UNO tutorial but is for developers familiar with the concepts to showcase the advantages of Apache Groovy + UNO.

This documentation's AsciiDoc source is maintained in the docs folder of the https://github.com/cbmarcum/guno-extension[GUNO-Extension Project] on GitHub.

== Getting the Extension
Projects that build using dependencies from artifact repositories like Apache Maven, JCenter, etc. just need to include
the latest version as a dependency in the build file or POM.

=== Gradle Projects
[source, gradle]
----
compile group: 'net.codebuilders', name: 'guno-extension', version: '4.1.6.13'
----

=== Maven Projects
[source, xml]
----
<dependency>
    <groupId>net.codebuilders</groupId>
    <artifactId>guno-extension</artifactId>
    <version>4.1.6.13</version>
</dependency>
----

=== Groovy Scripts 
Groovy scripts can declare a Grab dependency at the beginning before import statements.
[source, groovy]
----
@Grapes(
    @Grab(group='net.codebuilders', module='guno-extension', version='4.1.6.13')
)
----

=== OpenOffice Macros 
Macros written in Groovy do not need to include a dependency as the guno-extension jar file is packaged with the https://github.com/cbmarcum/openoffice-groovy[OpenOffice-Groovy] extension. OpenOffice-Groovy is an Extension for OpenOffice that adds Groovy as a Macro language. It is not required to use Groovy for standalone client applications or OpenOffice Extensions. It is required to use the Macro examples in this documentation.

== Groovy Syntax
There are many advantages to using the Groovy language over pure Java and most can be found in the
http://groovy-lang.org/documentation.html[Apache Groovy documentation].
A few things we'll point out here are while Java requires us to cast an Object to a type like when using the queryInterface
method, Groovy does the casting automatically. We also don't need line-ending semicolons.

*Java*
[source, java]
----
XIndexAccess xIndexSheets = (XIndexAccess) UnoRuntime.queryInterface(XIndexAccess.class, xSheets);
----
*Groovy*
[source, groovy]
----
XIndexAccess xIndexSheets = UnoRuntime.queryInterface(XIndexAccess.class, xSheets)
----

While Groovy works great as a dynamic language where we can declare variables with the _def_ keyword, I prefer to declare
types most of the time. This is only my preference and not a requirement.
When Object properties have getter and setter methods to use, Groovy allows what appears to be property access while actually
using the get and set methods at compile time.

*Java*
[source,java]
----
XSpreadsheets xSheets = myDoc.getSheets();
----
*Groovy*
[source,groovy]
----
XSpreadsheets xSheets = myDoc.sheets
----

== Using the Extension
The best way to explain the differences between the Java UNO API's and using Groovy with and without the extension is with some example code. Many of the examples are spreadsheet examples are from SCalc.java that is included with the AOO SDK.

=== Import Statement
Add the UnoExtention to imports
[source, groovy]
----
import org.openoffice.guno.UnoExtension
----

=== Get an XComponentLoader
One of the first objects we need in AOO development  after we bootstrap the office and acquire an XComponentContext is an
XComponentLoader we can use to load a document. This requires a few steps as shown:

*Groovy* (begins with a XComponentContext _xComponentContext_ reference)
[source,groovy]
----
XMultiComponentFactory mxRemoteServiceManager = null
    XComponentLoader aLoader = null
    mxRemoteServiceManager = xComponentContext.getServiceManager()
    aLoader = UnoRuntime.queryInterface(
        XComponentLoader.class, mxRemoteServiceManager.createInstanceWithContext(
        "com.sun.star.frame.Desktop", self))
----

The GUNO Extension adds a convenience method _getComponentLoader()_ to the XComponentContext class to return an XComponentLoader object.

*GUNO Extension* (same _xComponentContext_ reference)

[source,groovy]
----
XComponentLoader aLoader = xComponentContext.componentLoader
----

=== UnoRuntime.queryInterface
A common task in OpenOffice development with Java is using the static _UnoRuntime.queryInterface()_ method to get an
Interface reference from another within the same Service object. The UNO concepts of Services and Intefaces are beyond
the scope of this guide, but you can get more information in the https://wiki.openoffice.org/wiki/Documentation/DevGuide[AOO Development Guide].

The _UnoRuntime.queryInterface(ReturnObject.class, FromObject)_ method can be replaced with the new _FromObject.guno(ReturnObject.class)_ method.

*Java* (assumes we have a reference to XSpreadsheetDocument _myDoc_)
[source,java]
----
XSpreadsheets xSheets = myDoc.getSheets();
XIndexAccess oIndexSheets = (XIndexAccess) UnoRuntime.queryInterface(XIndexAccess.class, xSheets);
xSheet = (XSpreadsheet) UnoRuntime.queryInterface(XSpreadsheet.class, oIndexSheets.getByIndex(0));
----

*GUNO Extension*
[source,java]
----
XSpreadsheets xSheets = myDoc.sheets
XIndexAccess oIndexSheets = xSheets.guno(XIndexAccess.class)
xSheet = oIndexSheets.getByIndex(0).guno(XSpreadsheet.class)
----

=== Property Access
An UNO object must offer its properties through interfaces that allow you to work with properties. The most basic form
of these interfaces is the interface com.sun.star.beans.XPropertySet .

In XPropertySet, two methods carry out the property access: + 
_Object getPropertyValue(String propertyName)_ + 
_void setPropertyValue(String propertyName, Object propertyValue)_ + 

The GUNO Extension adds two special methods to XPropertySet: + 
_Object getAt(String propertyName)_ + 
_void putAt(String propertyName, Object propertyValue)_ + 

Example: Set the CellStyle of a spreadsheet Cell _xCell_.

*Java*
[source,java]
----
XPropertySet xCellProps = (XPropertySet)UnoRuntime.queryInterface(XPropertySet.class, xCell);
xCellProps.setPropertyValue("CellStyle", "Result");
----

*GUNO Extension*
[source,groovy]
----
XPropertySet xCellProps = xCell.guno(XPropertySet.class)
xCellProps.putAt("CellStyle", "Result")
----

These special methods allow a shorthand version to getAt and PutAt using  http://groovy-lang.org/operators.html#subscript-operator[Groovy Subscript Operator] notation. This can Get or Set properties depending on which side of the assigment it's on.

*GUNO Extension* using Subscript operator for assignment.
[source,groovy]
----
xCellProps["CellStyle"] = "Result"
----

See below for an even faster method to set Cell Properties.

=== Spreadsheet By Index and Name
The GUNO Extension adds a method to XSpreadsheetDocument that returns the XSpreadsheet by the index position saving the steps of getting the XIndexAccess enumeration of sheets and then getting the sheet by index. Likewise there is a method that uses the sheet name. + 
_XSpreadsheet getSheetByIndex(Integer nIndex)_ + 
_XSpreadsheet getSheetByName(String name)_


The example leaves out the try/catch for brevity and assumes we have a reference to XSpreadsheetDocument _myDoc_

*Java*
[source,java]
----
XSpreadsheets xSheets = myDoc.getSheets();
XIndexAccess oIndexSheets = (XIndexAccess) UnoRuntime.queryInterface(XIndexAccess.class, xSheets);
xSheet = (XSpreadsheet) UnoRuntime.queryInterface(XSpreadsheet.class, oIndexSheets.getByIndex(0));
----

*GUNO Extension*
[source,groovy]
----
XSpreadsheet xSheet = myDoc.getSheetByIndex(0)
----

From this point on, the examples are Groovy without and then with the GUNO Extension.

=== Cell Contents

The GUNO Extension adds getters and setters for cell Formulas (text) and Values (numeric) to XCellRange. This allows you to get or set the contents of a cell by it's position in a XCellRange, XSheetCellRange, or XSpreadsheet depending on which Interface  you use. +
The methods are: +
_String getFormulaOfCell(int column, int row)_ + 
_void setFormulaOfCell(int column, int row, String value)_ +
_Double getValueOfCell(int column, int row)_ + 
_void setValueOfCell(int column, int row, float value)_


*Without Extension* (assumes we have an xSpreadsheet reference)
[source, groovy]
----
XCellRange xCellRange = UnoRuntime.queryInterface(XCellRange.class, xSpreadsheet)
xCell = xCellRange.getCellByPosition(2,2)
XText xCellText = UnoRuntime.queryInterface(XText.class, xCell)
xCellText.setString("Quotation")
----

*With Extension*
[source, groovy]
----
xSpreadsheet.setFormulaOfCell(2,2, "Quotation")
----

=== Cell Style

The extension adds getter and setter methods for CellStyle to XCell + 
_Object getCellStyle()_ + 
_void setCellStyle(Object value)_ + 
allowing what looks like property access to the CellStyle property. +
To set the cell style to "Result":

*Without Extension*

[source,java]
----
XPropertySet xCellProps = UnoRuntime.queryInterface(XPropertySet.class, xCell)
xCellProps.setPropertyValue("CellStyle", "Result")
----

*With extension*
[source,java]
----
xCell.cellStyle = "Result"
----

To get the style as a String:

*With Extension*
[source, groovy]
----
String style = xCell.cellStyle
----

=== CellVertJustify Enum

The extension adds getter and setter methods to XCell allowing what looks like property access to vertJustify and use the CellVertJustify enum types.
_Integer getVertJustify()_ + 
_void setVertJustify(Object value)_

*Without Extension*
[source,groovy]
----
xCellProps.setPropertyValue("VertJustify", com.sun.star.table.CellVertJustify.TOP)
----

*With Extension*
[source,groovy]
----
xCell.vertJustify = com.sun.star.table.CellVertJustify.TOP
----

=== Cell Ranges
The GUNO Extension adds a method XSpeadsheet to get the the cell ranges that match certain types. + 
_XSheetCellRanges getCellRanges(Object type)_ + 
where type is one or a combination of  http://www.openoffice.org/api/docs/common/ref/com/sun/star/sheet/CellFlags.html[CellFlag constants].

*Without Extension*
[source,groovy]
----
XCellRangesQuery xCellQuery = UnoRuntime.queryInterface(XCellRangesQuery.class, xSpreadsheet)
XSheetCellRanges xFormulaCells = xCellQuery.queryContentCells((short)CellFlags.FORMULA)
----

*With Extension*
[source,groovy]
----
XSheetCellRanges xFormulaCells = xSpreadsheet.getCellRanges(CellFlags.FORMULA)
----

=== Use of XEnumerationAccess

*Without Extension* we get an Enumeration and use it iterate through Cells 

[source,java]
----
XEnumerationAccess xFormulas = xFormulaCells.getCells()
XEnumeration xFormulaEnum = xFormulas.createEnumeration()
while (xFormulaEnum.hasMoreElements()) {
    Object formulaCell = xFormulaEnum.nextElement()
    xCell = UnoRuntime.queryInterface(XCell.class, formulaCell)
    XCellAddressable xCellAddress = UnoRuntime.queryInterface(XCellAddressable.class, xCell)
    println("Formula cell in column " +
        xCellAddress.getCellAddress().Column + ", row " + xCellAddress.getCellAddress().Row
        + " contains " + xCell.getFormula())
}
----

*With Extension* we can use a List provided by a new method and a closure to iterate through each cell.

[source,java]
----
XCell[] cellList = xFormulaCells.cellList
cellList.each() {println("Formula cell in column ${it.address.Column}, " + 
    "row ${it.address.Row} contains ${it.formula}")
}
----

=== RangeContainer
Example: Create a new cell range container, add all cells that are filled, and iterate through them.

*Without Extension*

[source,java]
----
com.sun.star.lang.XMultiServiceFactory xDocFactory = UnoRuntime.queryInterface(
    com.sun.star.lang.XMultiServiceFactory.class, xSpreadsheetDocument)
com.sun.star.sheet.XSheetCellRangeContainer xRangeCont = UnoRuntime.queryInterface(
    com.sun.star.sheet.XSheetCellRangeContainer.class,
    xDocFactory.createInstance("com.sun.star.sheet.SheetCellRanges"));
xRangeCont.addRangeAddresses(xCellRanges.rangeAddresses, false)
print("All filled cells: ")
com.sun.star.container.XEnumerationAccess xCellsEA = xRangeCont.getCells()
com.sun.star.container.XEnumeration xEnum = xCellsEA.createEnumeration()          
while (xEnum.hasMoreElements()) {
    Object aCellObj = xEnum.nextElement()
    com.sun.star.sheet.XCellAddressable xAddr = UnoRuntime.queryInterface(
        com.sun.star.sheet.XCellAddressable.class, aCellObj)
    com.sun.star.table.CellAddress aAddr = xAddr.getCellAddress()
    println(sdHelper.getCellAddressString(aAddr.Column, aAddr.Row) + " ")
}
----

*With Extension*

[source,java]
----
XSheetCellRangeContainer xRangeCont = xSpreadsheetDocument.rangeContainer
XSheetCellRanges xCellRanges = xSpreadsheet.getCellRanges(1023)
XCell[] cellList2 = xRangeCont.cellList
print("All filled cells: ")
cellList2.each() {println("Formula cell in column ${it.address.Column}, " + 
    "row ${it.address.Row} contains ${it.formula}")
}
----

